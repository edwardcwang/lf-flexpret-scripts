#include "ctarget.h"
// Code generated by the Lingua Franca compiler from file:
// /lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf
#include "util.h"
#define NUMBER_OF_FEDERATES 1
#include "core/reactor.c"
// =============== START reactor class Controller
#line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
typedef struct {
#line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool value;
#line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool is_present;
#line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int num_destinations;
#line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
} controller_bumped_t;
#line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
typedef struct {
#line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool value;
#line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool is_present;
#line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int num_destinations;
#line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
} controller_pressed_t;
#line 58 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
typedef struct {
#line 58 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int* value;
#line 58 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool is_present;
#line 58 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int num_destinations;
#line 58 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    lf_token_t* token;
#line 58 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int length;
#line 58 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
} controller_move_t;
typedef struct {
    int bank_index;
    #line 61 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int _state;
    #line 62 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int driving_speed;
    #line 63 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int stop_speed;
    #line 64 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int driving_distance;
    #line 65 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int backing_distance;
    #line 66 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int turning_distance;
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    controller_bumped_t* __bumped;
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    // width of -2 indicates that it is not a multiport.
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int __bumped__width;
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    // Default input (in case it does not get connected)
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    controller_bumped_t __default__bumped;
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    controller_pressed_t* __pressed;
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    // width of -2 indicates that it is not a multiport.
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int __pressed__width;
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    // Default input (in case it does not get connected)
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    controller_pressed_t __default__pressed;
    #line 58 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    controller_move_t __move;
    #line 58 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int __move__width;
    #line 68 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    reaction_t ___reaction_0;
    #line 78 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    reaction_t ___reaction_1;
    #line 153 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    reaction_t ___reaction_2;
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    trigger_t ___bumped;
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    reaction_t* ___bumped_reactions[2];
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    trigger_t ___pressed;
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    reaction_t* ___pressed_reactions[1];
} controller_self_t;
void controllerreaction_function_0(void* instance_args) {
    controller_self_t* self = (controller_self_t*)instance_args;
    controller_pressed_t* pressed = self->__pressed;
    int pressed_width = self->__pressed__width;
    #line 69 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    magic_start_stamp(3);
    if (pressed->is_present && pressed->value == true) {
        self->_state = 1;
    }
    else if (pressed->is_present && pressed->value == false) {
        self->_state = 0;
    }
    magic_end_stamp(3);
        
}
void controllerreaction_function_1(void* instance_args) {
    controller_self_t* self = (controller_self_t*)instance_args;
    controller_bumped_t* bumped = self->__bumped;
    int bumped_width = self->__bumped__width;
    controller_move_t* move = &self->__move;
    #line 79 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    magic_start_stamp(4);
    // Dynamically allocate an output array of length 2.
    int* array = malloc(2 * sizeof(int));
    SET_ARRAY(move, array, sizeof(int), 2);
    
    // Paste the state machine here
    switch(self->_state) {
        // OFF
        case 0 : {
            printf("State OFF\n");
            move->value[0] = self->stop_speed;
            move->value[1] = self->stop_speed;
            break;
        }
        // DRIVING
        case 1 : {
            if (bumped->value == true) {
                self->_state = 3;
                break;
            }
            
            printf("State DRIVING\n");
            // FIXME: need to use sensors
            self->driving_distance += 1; 
            
            move->value[0] = self->driving_speed;
            move->value[1] = self->driving_speed;
            
            if (self->driving_distance > 20) {
                self->driving_distance = 0;
                self->_state = 2;
            }
            break;
        }
        // TURNING
        case 2 : {
            if (bumped->value == true) {
                self->_state = 3;
                break;
            }
            
            printf("State TURNING\n");
            // FIXME: need to use sensors
            self->turning_distance += 1; 
            
            move->value[0] = self->driving_speed;
            move->value[1] = -1 * self->driving_speed;
            
            if (self->turning_distance > 10) {
                self->turning_distance = 0;                    
                self->_state = 1;
            }
            break;
        }
        //BACKING UP
        case 3: {
            printf("State BACKING UP\n");
            // FIXME: need to use sensors
            self->backing_distance += 1;
            //cliff sensor
            move->value[0] = -1 * self->driving_speed;
            move->value[1] = -1 * self->driving_speed;
    
            if (self->backing_distance >= 10) {
                self->backing_distance = 0;
                self->_state = 2;
            }
            break;
        }
    }
    
    magic_end_stamp(4);
        
}
void controllerreaction_function_2(void* instance_args) {
    controller_self_t* self = (controller_self_t*)instance_args;
    controller_bumped_t* bumped = self->__bumped;
    int bumped_width = self->__bumped__width;
    #line 154 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    magic_start_stamp(5);
    // Logging sensor inputs...
    magic_end_stamp(5);
        
}
controller_self_t* new_Controller() {
    controller_self_t* self = (controller_self_t*)calloc(1, sizeof(controller_self_t));
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    // Set input by default to an always absent default input.
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->__bumped = &self->__default__bumped;
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    // Set input by default to an always absent default input.
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->__pressed = &self->__default__pressed;
    #line 68 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.number = 0;
    #line 68 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.function = controllerreaction_function_0;
    #line 68 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.self = self;
    #line 68 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.deadline_violation_handler = NULL;
    #line 68 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.tardy_handler = NULL;
    #line 78 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_1.number = 1;
    #line 78 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_1.function = controllerreaction_function_1;
    #line 78 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_1.self = self;
    #line 78 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_1.deadline_violation_handler = NULL;
    #line 78 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_1.tardy_handler = NULL;
    #line 153 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_2.number = 2;
    #line 153 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_2.function = controllerreaction_function_2;
    #line 153 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_2.self = self;
    #line 153 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_2.deadline_violation_handler = NULL;
    #line 153 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_2.tardy_handler = NULL;
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___bumped.last = NULL;
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___bumped_reactions[0] = &self->___reaction_1;
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___bumped_reactions[1] = &self->___reaction_2;
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___bumped.reactions = &self->___bumped_reactions[0];
    #line 56 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___bumped.number_of_reactions = 2;
    self->___bumped.element_size = sizeof(bool);
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___pressed.last = NULL;
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___pressed_reactions[0] = &self->___reaction_0;
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___pressed.reactions = &self->___pressed_reactions[0];
    #line 57 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___pressed.number_of_reactions = 1;
    self->___pressed.element_size = sizeof(bool);
    return self;
}
void delete_Controller(controller_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    if (self->___reaction_1.output_produced != NULL) {
        free(self->___reaction_1.output_produced);
    }
    if (self->___reaction_1.triggers != NULL) {
        free(self->___reaction_1.triggers);
    }
    if (self->___reaction_1.triggered_sizes != NULL) {
        free(self->___reaction_1.triggered_sizes);
    }
    if (self->___reaction_2.output_produced != NULL) {
        free(self->___reaction_2.output_produced);
    }
    if (self->___reaction_2.triggers != NULL) {
        free(self->___reaction_2.triggers);
    }
    if (self->___reaction_2.triggered_sizes != NULL) {
        free(self->___reaction_2.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_1.num_outputs; i++) {
        free(self->___reaction_1.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_2.num_outputs; i++) {
        free(self->___reaction_2.triggers[i]);
    }
    free(self);
}
// =============== END reactor class Controller

// =============== START reactor class Motors
#line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
typedef struct {
#line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int* value;
#line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool is_present;
#line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int num_destinations;
#line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    lf_token_t* token;
#line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int length;
#line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
} motors__in_t;
typedef struct {
    int bank_index;
    #line 162 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool stopped;
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    motors__in_t* ___in;
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    // width of -2 indicates that it is not a multiport.
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int ___in__width;
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    // Default input (in case it does not get connected)
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    motors__in_t __default___in;
    #line 163 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    reaction_t ___reaction_0;
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    trigger_t ____in;
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    reaction_t* ____in_reactions[1];
} motors_self_t;
void motorsreaction_function_0(void* instance_args) {
    motors_self_t* self = (motors_self_t*)instance_args;
    motors__in_t* _in = self->___in;
    if (_in->is_present) {
        _in->length = _in->token->length;
        _in->value = (int*)_in->token->value;
    } else {
        _in->length = 0;
    }
    int _in_width = self->___in__width;
    #line 164 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    magic_start_stamp(6);
    if (!self->stopped) {
        printf("left motor: %d, right motor: %d\n", _in->value[0], _in->value[1]);   
    }
    magic_end_stamp(6);
        
}
motors_self_t* new_Motors() {
    motors_self_t* self = (motors_self_t*)calloc(1, sizeof(motors_self_t));
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    // Set input by default to an always absent default input.
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___in = &self->__default___in;
    #line 163 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.number = 0;
    #line 163 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.function = motorsreaction_function_0;
    #line 163 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.self = self;
    #line 163 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.deadline_violation_handler = NULL;
    #line 163 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.tardy_handler = NULL;
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->____in.last = NULL;
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->____in_reactions[0] = &self->___reaction_0;
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->____in.reactions = &self->____in_reactions[0];
    #line 161 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->____in.number_of_reactions = 1;
    self->____in.element_size = sizeof(int);
    return self;
}
void delete_Motors(motors_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    free(self);
}
// =============== END reactor class Motors

// =============== START reactor class Sensors
#line 8 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
typedef struct {
#line 8 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool value;
#line 8 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool is_present;
#line 8 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int num_destinations;
#line 8 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
} sensors_button_out_t;
#line 9 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
typedef struct {
#line 9 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool value;
#line 9 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool is_present;
#line 9 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int num_destinations;
#line 9 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
} sensors_bumper_out_t;
#line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
typedef struct {
#line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    trigger_t* trigger;
#line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    char value;
#line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool is_present;
#line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool has_value;
#line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    lf_token_t* token;
#line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
} sensors_button_press_t;
typedef struct {
    int bank_index;
    #line 11 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    bool button;
    #line 12 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int time_to_next_bump;
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    sensors_button_press_t __button_press;
    #line 8 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    sensors_button_out_t __button_out;
    #line 8 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int __button_out__width;
    #line 9 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    sensors_bumper_out_t __bumper_out;
    #line 9 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    int __bumper_out__width;
    #line 20 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    reaction_t ___reaction_0;
    #line 27 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    reaction_t ___reaction_1;
    #line 38 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    reaction_t ___reaction_2;
    #line 18 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    trigger_t ___sensor_pull;
    #line 18 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    reaction_t* ___sensor_pull_reactions[1];
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    trigger_t ___button_press;
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    reaction_t* ___button_press_reactions[1];
} sensors_self_t;
void sensorsreaction_function_0(void* instance_args) {
    sensors_self_t* self = (sensors_self_t*)instance_args;
    sensors_button_press_t* button_press = &self->__button_press;
    #line 21 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    magic_start_stamp(0);
    schedule(button_press, 0);
    magic_end_stamp(0);       
        
}
void sensorsreaction_function_1(void* instance_args) {
    sensors_self_t* self = (sensors_self_t*)instance_args;
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    // Expose the action struct as a local variable whose name matches the action name.
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    sensors_button_press_t* button_press = &self->__button_press;
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    // Set the fields of the action struct to match the current trigger.
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    button_press->is_present = self->___button_press.is_present;
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    button_press->has_value = ((self->___button_press.token) != NULL && (self->___button_press.token)->value != NULL);
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    button_press->token = (self->___button_press.token);
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    if (button_press->has_value) {
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
        button_press->value = *(char*)(self->___button_press.token)->value;
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    }
    sensors_button_out_t* button_out = &self->__button_out;
    #line 28 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    magic_start_stamp(1);
    self->button = !self->button;
    printf("Button status: %d\n", self->button);
    SET(button_out, self->button);
    magic_end_stamp(1);
        
}
void sensorsreaction_function_2(void* instance_args) {
    sensors_self_t* self = (sensors_self_t*)instance_args;
    sensors_bumper_out_t* bumper_out = &self->__bumper_out;
    #line 39 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    magic_start_stamp(2);
    if (self->time_to_next_bump == 0) {
        SET(bumper_out, true);
        printf("Bumper detects an obstacle!\n");
        self->time_to_next_bump = 25;
    } else {
        SET(bumper_out, false);
        self->time_to_next_bump--;
    }
    magic_end_stamp(2);
        
}
sensors_self_t* new_Sensors() {
    sensors_self_t* self = (sensors_self_t*)calloc(1, sizeof(sensors_self_t));
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->__button_press.trigger = &self->___button_press;
    #line 20 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.number = 0;
    #line 20 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.function = sensorsreaction_function_0;
    #line 20 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.self = self;
    #line 20 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.deadline_violation_handler = NULL;
    #line 20 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_0.tardy_handler = NULL;
    #line 27 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_1.number = 1;
    #line 27 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_1.function = sensorsreaction_function_1;
    #line 27 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_1.self = self;
    #line 27 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_1.deadline_violation_handler = NULL;
    #line 27 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_1.tardy_handler = NULL;
    #line 38 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_2.number = 2;
    #line 38 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_2.function = sensorsreaction_function_2;
    #line 38 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_2.self = self;
    #line 38 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_2.deadline_violation_handler = NULL;
    #line 38 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___reaction_2.tardy_handler = NULL;
    #line 18 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___sensor_pull.last = NULL;
    #line 18 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    #line 18 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___sensor_pull_reactions[0] = &self->___reaction_2;
    #line 18 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___sensor_pull.reactions = &self->___sensor_pull_reactions[0];
    #line 18 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___sensor_pull.number_of_reactions = 1;
    self->___sensor_pull.is_timer = true;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.last = NULL;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = false;
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___button_press.last = NULL;
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___button_press_reactions[0] = &self->___reaction_1;
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___button_press.reactions = &self->___button_press_reactions[0];
    #line 15 "file:/lf-flexpret-scripts/lf/demo_2/demo_robot_with_id.lf"
    self->___button_press.number_of_reactions = 1;
    self->___button_press.is_physical = false;
    self->___button_press.element_size = sizeof(char);
    return self;
}
void delete_Sensors(sensors_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    if (self->___reaction_1.output_produced != NULL) {
        free(self->___reaction_1.output_produced);
    }
    if (self->___reaction_1.triggers != NULL) {
        free(self->___reaction_1.triggers);
    }
    if (self->___reaction_1.triggered_sizes != NULL) {
        free(self->___reaction_1.triggered_sizes);
    }
    if (self->___reaction_2.output_produced != NULL) {
        free(self->___reaction_2.output_produced);
    }
    if (self->___reaction_2.triggers != NULL) {
        free(self->___reaction_2.triggers);
    }
    if (self->___reaction_2.triggered_sizes != NULL) {
        free(self->___reaction_2.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_1.num_outputs; i++) {
        free(self->___reaction_1.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_2.num_outputs; i++) {
        free(self->___reaction_2.triggers[i]);
    }
    free(self);
}
// =============== END reactor class Sensors

// =============== START reactor class Robot
typedef struct {
    int bank_index;
} robot_self_t;
robot_self_t* new_Robot() {
    robot_self_t* self = (robot_self_t*)calloc(1, sizeof(robot_self_t));
    return self;
}
void delete_Robot(robot_self_t* self) {
    free(self);
}
// =============== END reactor class Robot

void __set_default_command_line_options() {
}
// Array of pointers to timer triggers to be scheduled in __initialize_timers().
trigger_t* __timer_triggers[1];
int __timer_triggers_size = 1;
// Array of pointers to timer triggers to be scheduled in __trigger_startup_reactions().
reaction_t* __startup_reactions[1];
int __startup_reactions_size = 1;
// Empty array of pointers to shutdown triggers.
reaction_t** __shutdown_reactions = NULL;
int __shutdown_reactions_size = 0;
trigger_t* __action_for_port(int port_id) {
    return NULL;
}
void __initialize_trigger_objects() {
    __tokens_with_ref_count_size = 2;
    __tokens_with_ref_count = (token_present_t*)malloc(2 * sizeof(token_present_t));
    // Create the array that will contain pointers to is_present fields to reset on each step.
    __is_present_fields_size = 4;
    __is_present_fields = (bool**)malloc(4 * sizeof(bool*));
    // ************* Instance Robot of class Robot
    robot_self_t* robot_self = new_Robot();
    //***** Start initializing Robot
    // ************* Instance Robot.sensors of class Sensors
    sensors_self_t* robot_sensors_self = new_Sensors();
    //***** Start initializing Robot.sensors
    // width of -2 indicates that it is not a multiport.
    robot_sensors_self->__button_out__width = -2;
    // width of -2 indicates that it is not a multiport.
    robot_sensors_self->__bumper_out__width = -2;
    __startup_reactions[0] = &robot_sensors_self->___reaction_0;
    static bool robot_sensors_initial_button = false;
    robot_sensors_self->button = robot_sensors_initial_button;
    static int robot_sensors_initial_time_to_next_bump = 25;
    robot_sensors_self->time_to_next_bump = robot_sensors_initial_time_to_next_bump;
    robot_sensors_self->___button_press.offset = 0;
    robot_sensors_self->___button_press.period = -1;
    robot_sensors_self->___sensor_pull.offset = 0;
    robot_sensors_self->___sensor_pull.period = MSEC(100);
    __timer_triggers[0] = &robot_sensors_self->___sensor_pull;
    robot_sensors_self->___button_press.token = __create_token(sizeof(char));
    robot_sensors_self->___button_press.is_present = false;
    __tokens_with_ref_count[0].token
            = &robot_sensors_self->___button_press.token;
    __tokens_with_ref_count[0].is_present
            = &robot_sensors_self->___button_press.is_present;
    __tokens_with_ref_count[0].reset_is_present = true;
    //***** End initializing Robot.sensors
    // ************* Instance Robot.motors of class Motors
    motors_self_t* robot_motors_self = new_Motors();
    //***** Start initializing Robot.motors
    // width of -2 indicates that it is not a multiport.
    robot_motors_self->___in__width = -2;
    static bool robot_motors_initial_stopped = false;
    robot_motors_self->stopped = robot_motors_initial_stopped;
    //***** End initializing Robot.motors
    // ************* Instance Robot.controller of class Controller
    controller_self_t* robot_controller_self = new_Controller();
    //***** Start initializing Robot.controller
    // width of -2 indicates that it is not a multiport.
    robot_controller_self->__move__width = -2;
    // width of -2 indicates that it is not a multiport.
    robot_controller_self->__bumped__width = -2;
    // width of -2 indicates that it is not a multiport.
    robot_controller_self->__pressed__width = -2;
    static int robot_controller_initial__state = 0;
    robot_controller_self->_state = robot_controller_initial__state;
    static int robot_controller_initial_driving_speed = 80;
    robot_controller_self->driving_speed = robot_controller_initial_driving_speed;
    static int robot_controller_initial_stop_speed = 0;
    robot_controller_self->stop_speed = robot_controller_initial_stop_speed;
    static int robot_controller_initial_driving_distance = 0;
    robot_controller_self->driving_distance = robot_controller_initial_driving_distance;
    static int robot_controller_initial_backing_distance = 0;
    robot_controller_self->backing_distance = robot_controller_initial_backing_distance;
    static int robot_controller_initial_turning_distance = 0;
    robot_controller_self->turning_distance = robot_controller_initial_turning_distance;
    //***** End initializing Robot.controller
    //***** End initializing Robot
    // Populate arrays of trigger pointers.
    robot_self->bank_index = 0;
    robot_sensors_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    robot_sensors_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (robot_sensors_self->___reaction_0.num_outputs > 0) {
        robot_sensors_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * robot_sensors_self->___reaction_0.num_outputs);
        robot_sensors_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * robot_sensors_self->___reaction_0.num_outputs);
        robot_sensors_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * robot_sensors_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    robot_sensors_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (robot_sensors_self->___reaction_1.num_outputs > 0) {
        robot_sensors_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * robot_sensors_self->___reaction_1.num_outputs);
        robot_sensors_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * robot_sensors_self->___reaction_1.num_outputs);
        robot_sensors_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * robot_sensors_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    robot_sensors_self->___reaction_1.output_produced[0]
    = &robot_sensors_self->__button_out.is_present
    ;
    // Total number of outputs produced by the reaction.
    robot_sensors_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (robot_sensors_self->___reaction_2.num_outputs > 0) {
        robot_sensors_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * robot_sensors_self->___reaction_2.num_outputs);
        robot_sensors_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * robot_sensors_self->___reaction_2.num_outputs);
        robot_sensors_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * robot_sensors_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    robot_sensors_self->___reaction_2.output_produced[0]
    = &robot_sensors_self->__bumper_out.is_present
    ;
    // Reaction 0 of Robot.sensors does not depend on one maximal upstream reaction.
    robot_sensors_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of Robot.sensors depends on one maximal upstream reaction.
    robot_sensors_self->___reaction_1.last_enabling_reaction = &(robot_sensors_self->___reaction_0);
    // Reaction 1 of Robot.sensors triggers 1 downstream reactions through port Robot.sensors.button_out.
    robot_sensors_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of Robot.sensors, allocate an
    // array of trigger pointers for downstream reactions through port Robot.sensors.button_out
    trigger_t** robot_sensors_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    robot_sensors_self->___reaction_1.triggers[0] = robot_sensors_1_0;
    // Point to destination port Robot.controller.pressed's trigger struct.
    robot_sensors_1_0[0] = &robot_controller_self->___pressed;
    // Reaction 2 of Robot.sensors depends on one maximal upstream reaction.
    robot_sensors_self->___reaction_2.last_enabling_reaction = &(robot_sensors_self->___reaction_1);
    // Reaction 2 of Robot.sensors triggers 1 downstream reactions through port Robot.sensors.bumper_out.
    robot_sensors_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of Robot.sensors, allocate an
    // array of trigger pointers for downstream reactions through port Robot.sensors.bumper_out
    trigger_t** robot_sensors_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    robot_sensors_self->___reaction_2.triggers[0] = robot_sensors_2_0;
    // Point to destination port Robot.controller.bumped's trigger struct.
    robot_sensors_2_0[0] = &robot_controller_self->___bumped;
    robot_sensors_self->__button_out.num_destinations
    = 1;
    robot_sensors_self->__bumper_out.num_destinations
    = 1;
    robot_motors_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    robot_motors_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (robot_motors_self->___reaction_0.num_outputs > 0) {
        robot_motors_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * robot_motors_self->___reaction_0.num_outputs);
        robot_motors_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * robot_motors_self->___reaction_0.num_outputs);
        robot_motors_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * robot_motors_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of Robot.motors depends on one maximal upstream reaction.
    robot_motors_self->___reaction_0.last_enabling_reaction = &(robot_controller_self->___reaction_1);
    robot_controller_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    robot_controller_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (robot_controller_self->___reaction_0.num_outputs > 0) {
        robot_controller_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * robot_controller_self->___reaction_0.num_outputs);
        robot_controller_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * robot_controller_self->___reaction_0.num_outputs);
        robot_controller_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * robot_controller_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    robot_controller_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (robot_controller_self->___reaction_1.num_outputs > 0) {
        robot_controller_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * robot_controller_self->___reaction_1.num_outputs);
        robot_controller_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * robot_controller_self->___reaction_1.num_outputs);
        robot_controller_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * robot_controller_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    robot_controller_self->___reaction_1.output_produced[0]
    = &robot_controller_self->__move.is_present
    ;
    // Total number of outputs produced by the reaction.
    robot_controller_self->___reaction_2.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (robot_controller_self->___reaction_2.num_outputs > 0) {
        robot_controller_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * robot_controller_self->___reaction_2.num_outputs);
        robot_controller_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * robot_controller_self->___reaction_2.num_outputs);
        robot_controller_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * robot_controller_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of Robot.controller depends on one maximal upstream reaction.
    robot_controller_self->___reaction_0.last_enabling_reaction = &(robot_sensors_self->___reaction_1);
    // Reaction 1 of Robot.controller does not depend on one maximal upstream reaction.
    robot_controller_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 1 of Robot.controller triggers 1 downstream reactions through port Robot.controller.move.
    robot_controller_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of Robot.controller, allocate an
    // array of trigger pointers for downstream reactions through port Robot.controller.move
    trigger_t** robot_controller_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    robot_controller_self->___reaction_1.triggers[0] = robot_controller_1_0;
    // Point to destination port Robot.motors._in's trigger struct.
    robot_controller_1_0[0] = &robot_motors_self->____in;
    // Reaction 2 of Robot.controller depends on one maximal upstream reaction.
    robot_controller_self->___reaction_2.last_enabling_reaction = &(robot_controller_self->___reaction_1);
    robot_controller_self->__move.num_destinations
    = 1;
    // doDeferredInitialize
    robot_controller_self->__move.token = __create_token(sizeof(int));
    // Connect inputs and outputs for reactor Robot.
    // Connect Robot.sensors.button_out to input port Robot.controller.pressed
    robot_controller_self->__pressed = (controller_pressed_t*)&robot_sensors_self->__button_out;
    // Connect Robot.sensors.bumper_out to input port Robot.controller.bumped
    robot_controller_self->__bumped = (controller_bumped_t*)&robot_sensors_self->__bumper_out;
    // Connect Robot.controller.move to input port Robot.motors._in
    robot_motors_self->___in = (motors__in_t*)&robot_controller_self->__move;
    // Connect inputs and outputs for reactor Robot.sensors.
    // END Connect inputs and outputs for reactor Robot.sensors.
    // Connect inputs and outputs for reactor Robot.motors.
    // END Connect inputs and outputs for reactor Robot.motors.
    // Connect inputs and outputs for reactor Robot.controller.
    // END Connect inputs and outputs for reactor Robot.controller.
    // END Connect inputs and outputs for reactor Robot.
    // Add action Robot.sensors.button_press to array of is_present fields.
    __is_present_fields[0] 
            = &robot_sensors_self->__button_press.is_present;
    __tokens_with_ref_count[1].token
            = &robot_motors_self->___in->token;
    __tokens_with_ref_count[1].is_present
            = &robot_motors_self->___in->is_present;
    __tokens_with_ref_count[1].reset_is_present = false;
    // Add port Robot.sensors.button_out to array of is_present fields.
    __is_present_fields[1] = &robot_sensors_self->__button_out.is_present
    ;
    // Add port Robot.sensors.bumper_out to array of is_present fields.
    __is_present_fields[2] = &robot_sensors_self->__bumper_out.is_present
    ;
    // Add port Robot.controller.move to array of is_present fields.
    __is_present_fields[3] = &robot_controller_self->__move.is_present
    ;
    robot_sensors_self->___reaction_0.chain_id = 31;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    robot_sensors_self->___reaction_0.index = 0x7fffffffffff0000LL;
    robot_sensors_self->___reaction_1.chain_id = 31;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    robot_sensors_self->___reaction_1.index = 0x7fffffffffff0001LL;
    robot_sensors_self->___reaction_2.chain_id = 13;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    robot_sensors_self->___reaction_2.index = 0x7fffffffffff0002LL;
    robot_motors_self->___reaction_0.chain_id = 24;
    // index is the OR of level 4 and 
    // deadline 140737488355327 shifted left 16 bits.
    robot_motors_self->___reaction_0.index = 0x7fffffffffff0004LL;
    robot_controller_self->___reaction_0.chain_id = 18;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    robot_controller_self->___reaction_0.index = 0x7fffffffffff0002LL;
    robot_controller_self->___reaction_1.chain_id = 27;
    // index is the OR of level 3 and 
    // deadline 140737488355327 shifted left 16 bits.
    robot_controller_self->___reaction_1.index = 0x7fffffffffff0003LL;
    robot_controller_self->___reaction_2.chain_id = 7;
    // index is the OR of level 4 and 
    // deadline 140737488355327 shifted left 16 bits.
    robot_controller_self->___reaction_2.index = 0x7fffffffffff0004LL;
}
void __trigger_startup_reactions() {
    
    for (int i = 0; i < __startup_reactions_size; i++) {
        if (__startup_reactions[i] != NULL) {
            _lf_enqueue_reaction(__startup_reactions[i]);
        }
    }
}
void __initialize_timers() {
    for (int i = 0; i < __timer_triggers_size; i++) {
        if (__timer_triggers[i] != NULL) {
            _lf_initialize_timer(__timer_triggers[i]);
        }
    }
}
void logical_time_complete(instant_t timestep, microstep_t microstep) {
}
tag_t next_event_tag(instant_t time, microstep_t microstep) {
    return (tag_t) {  .time = time, .microstep = microstep };
}
bool __trigger_shutdown_reactions() {                          
    for (int i = 0; i < __shutdown_reactions_size; i++) {
        if (__shutdown_reactions[i] != NULL) {
            _lf_enqueue_reaction(__shutdown_reactions[i]);
        }
    }
    // Return true if there are shutdown reactions.
    return (__shutdown_reactions_size > 0);
}
void __termination() {stop_trace();}
